# 도커 설치, 컨테이너 서비스를 위한 도커 활용

### 도커 엔진

- 도커는 기존 리눅스 컨테이너(LXC) 기술을 이용하여 애플리케이션을 컨테이너로서 사용할 수 있게 만들었다.
- 현재는 리눅스 플랫폼에 의존적인 LXC 대신 runC OCI를 활용한다.
- chroot, cgroup, namespace API를 사용하므로 프로세스 단위의 격리 환경을 만들 수 있다.
- 도커 엔진은 클라이언트와 서버로 구분된다.
    - 클라이언트: 도커 명령을 받고, 결과를 출력함. 명령을 받기 위해 사용자에게 명령을 수행하는 명령줄을 제공함.
    - 서버: 도커 엔진, 즉 도커 데몬을 이용하여 컨테이너 시작, 운영, 정지 등을 담당함.
        - 도커 데몬은 docker.socket이 보유한 도커 API를 이용해 컨테이너를 생성하고, 수행된 컨테이너에 포함된 서비스 결과를 클라이언트에게 전달함.
        - docker.socket은 도커 데몬의 동작을 변경할 수 있는 매개 변수가 포함되어 있음.

## 컨테이너 서비스

### 컨테이너 서비스란?

- 컨테이너: 격리된 공간에서 프로세스가 동작하는 기술
- 애플리케이션 개발 환경이 도커 기반의 컨테이너 서비스 환경으로 전환된 이유는?
    - 가변적 인프라 환경으로 인한 일관성 없는 환경 때문이다.
    - 컨테이너 서비스는 애플리케이션 실행에 필요한 바이너리, 라이브러리 및 구성 파일 등을 패키지로 묶어 배포한다.
    - 따라서 어떤 환경에서든 컨테이너 기반의 애플리케이션을 개발하고 배포할 수 있다.
- 가상화 방식
    - 하드웨어 레벨 가상화: 하이퍼바이저 등을 이용한 가상 머신 방식
    - 운영체제 레벨 가상화: 컨테이너 기반의 애플리케이션 서비스 방식

### 왜 도커 컨테이너 서비스일까?

- 도커 기반 애플리케이션 개발의 라이프사이클
    - 애플리케이션 코드 개발
    - 베이스 이미지를 이용한 Dockerfile 작성
        - 도커 허브를 통해 베이스 이미지를 다운로드하고, 다양한 구동 명령어와 각종 애플리케이션 코드, 라이브러리를 Dockerfile에 작성한다.
    - Dockerfile build를 통한 새로운 이미지 생성
    - 생성된 이미지를 이용한 컨테이너 실행 or 도커 컴포즈를 이용한 다중 컨테이너 실행
    - 컨테이너 애플리케이션 서비스(ex. nginx) 테스트 or 마이크로서비스(MSA) 테스트
    - 로컬 및 원격 저장소에 이미지 저장
    - 깃허브 등을 활용한 Dockerfile 관리
    - 동일 환경에서의 지속적 애플리케이션 개발 수행
- 도커는 컨테이너 동작에 필요한 모든 내용을 사전에 코드로 작성하여 앤서블 등과 같은 인프라 프로비저닝 도구로 자동화하므로 기업이 필요할 때마다 애플리케이션 및 서버 환경을 적은 비용으로 빠르게 개발, 배포, 확장이 가능하다. (IaC: 코드로서의 인프라스트럭처)

## 도커 명령어 활용

### 도커 이미지 명령어

```bash
# 도커 이미지 내려 받기 (DIGEST는 도커 허브에서 관리하는 이미지 고유 식별값임.)
$ docker [image] pull [OPTIONS] name[:TAG | @IMAGE_DIGEST]

# 다운로드한 이미지 정보 조회
$ docker image ls

# 도커 이미지 세부 정보 조회
$ docker image inspect [OPTIONS] IMAGE [IMAGE...]

# 도커 이미지를 구성하고 있는 레이어와 실행 정보 조회
$ docker image history [OPTIONS] IMAGE

# 도커 이미지 태그 설정
$ docker tag 원본 이미지[:태그] 참조 이미지[:태그]

# 도커 허브 관련
$ docker login
$ docker push 이미지 태그
$ docker logout

# 도커 이미지를 tar 파일로 저장.
$ docker image save [OPTIONS] <파일명> [image명]

# docker save로 저장한 tar 파일을 이미지로 불러옴.
$ docker image load [OPTIONS]

# 도커 이미지 삭제
$ docker rmi [OPTIONS] {이미지 이름[:태그] | 이미지 ID}

# 컨테이너가 연결되지 않은 도커 이미지 일괄 삭제 (-a를 붙이면 사용 중이 아닌 이미지까지 삭제)
$ docker image prune
```

**도커 유니온 파일 시스템**

![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F11e6d3dc-eaa8-4a4c-a041-1ac06a4bbdc5%2FUntitled.png?table=block&id=8404d563-7934-4f75-924a-737571333fa9&spaceId=b453bd85-cb15-44b5-bf2e-580aeda8074e&width=2000&userId=80352c12-65a4-4562-9a36-2179ed0dfffb&cache=v2)

- 도커 이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있기 때문에 보통 용량이 수백메가에 이른다. 처음 이미지를 다운받을 땐 크게 부담이 안되지만 기존 이미지에 파일 하나 추가했다고 수백메가를 다시 다운받는다면 매우 비효율적일 수 밖에 없다.
- 그래서 도커는 레이어 개념을 사용하여 미리 다운 받아뒀던 레이어를 재사용하고, 새로운 레이어만 다운로드 받아서 하나의 이미지를 만들어 낸다.
- 도커 유니온 파일 시스템은 다음과 같다. (사진 부연 설명)
    - 도커 이미지 구조의 기본 운영체제 레이어들을 쌓는다. (ubuntu)
    - 운영체제 베이스 이미지 위에 아파치 웹 서버를 설치한 레이어를 올린다. (nginx 레이어만 추가 됨.)
    - 아파치 웹 서비스에 필요한 리소스 정보 및 환경 정보가 포함된 레이어를 올린다. 이렇게 구성된 이미지는 불변의 읽기 전용 레이어들의 집합 구조인 유니온 파일 시스템이다.
    - 도커 이미지를 실행하면 여러 개의 컨테이너를 구동할 수 있는데, 각각의 컨테이너에서 발생한 모든 변경 정보를 저장하기 위해 읽기-쓰기 레이어를 두고 저장하게 된다.

### 도커 컨테이너 명령어

**컨테이너는 프로세스다.**

- 도커 컨테이너는 도커 이미지를 기반으로 만들어지는 스냅숏이다.
- 이 스냅숏은 읽기 전용의 도커 이미지 레이어를 복제한 것이고, 그 위에 읽고 쓰기가 가능한 컨테이너 레이어를 결합하면 컨테이너가 된다.
    - 도커 컨테이너 = 도커 이미지 레이어 + 컨테이너 레이어
- `docker run` 명령어를 사용하면 컨테이너가 동작하고, 가상의 격리 환경에 독립된 프로세스가 동작한다.
- 리눅스 호스트 운영체제를 부팅하면 PID 1번은 init(systemd) 프로세스가 동작하며, 이 프로세스는 나머지 모든 시스템 프로세스의 부모 프로세스가 된다.
    - 이처럼 독립된 호스트 운영 체제는 init 프로세스와 같은 최상위 부모 프로세스가 필요하다.
    - 그럼 도커 컨테이너의 PID 1번 프로세스도 init 프로세스일까?
        - 아니다. 도커 컨테이너 자체가 1번 PID를 갖는다.
        - docker run을 수행할 때, PID 네임 스페이스 커널 기능을 통해 시스템의 1번 프로세스(init)의 PID를 공유하고 그 하위로 프로세스를 격리한다.
        - 또한, 이렇게 격리된 프로세스를 루트로 변경하는 chroot 커널 기능을 통해 독립된 1번 PID를 갖게 되고, 컨테이너 동작 시 필요한 자원에 대한 할당한 cgroups 커널 기능을 통해 이루어 진다.
        - 자세한 설명은 [해당 링크](https://www.44bits.io/ko/post/is-docker-container-a-virtual-machine-or-a-process) 참조.

**컨테이너 실행**

```bash
# docker create는 run과 달리 container 내부 접근을 하지 않고 생성(스냅숏)만 수행
$ docker create <옵션> [생성할 컨테이너 이름] [이미지]

# 도커 컨테이너 조회
$ docker ps <옵션>

# 생성된 스냅숏을 동작시킨다.
$ docker start [동작시킬 컨테이너 이름]

# 도커 컨테이너 접속 (단순 조회용)
$ docker attach [접속할 컨테이너 이름]

# 도커 이미지 복사본 스냅숏 레이어 위에 읽고 쓰기가 가능한 컨테이너 레이어를 추가하고, 컨테이너 시작함.
# 도커 이미지가 호스트 서버에 없으면 이미지를 자동으로 다운로드 함.
# 해당 컨테이너에 실행할 명령어(ex. docker ps)를 입력하면 컨테이너 동작과 함께 처리됨.
# docker run = [pull] + create + start + [command]
$ docker run [옵션] [생성할 컨테이너 이름] [이미지] [기타 명령어]

# 지정된 컨테이너의 모든 프로세스를 일시 중단.
$ docker pause [컨테이너 이름]

# 일시 중단된 컨테이너의 모든 프로세스를 중단 해제.
$ docker unpause [컨테이너 이름]

# 컨테이너 재시작(기존 컨테이너 프로세스를 정지하고, 새로운 컨테이너 프로세스를 시작함).
$ docker restart [컨테이너 이름]

# 컨테이너 내부의 파일을 호스트 서버로 복사
$ docker cp [컨테이너 이름]:[경로] [호스트 서버의 경로]

# 컨테이너 이름 변경
$ docker rename [변경할 컨테이너 이름] [수정할 컨테이너 이름]

# 컨테이너를 이미지로 생성 (이 방식보다는 주로 Dockerfile을 사용함.)
$ docker commit [컨테이너 이름] [이미지]
```

### 도커 볼륨 활용

- 도커 볼륨은 컨테이너에서 생성, 재사용할 수 있고 호스트 운영 체제에서 직접 접근이 가능하며, 보존되어야 하는 데이터를 유지하기 위한 메커니즘을 제공한다.
    - 일반적으로 컨테이너 내부의 데이터는 컨테이너의 라이프 사이클과 연관되어 컨테이너 종료 시 삭제된다. 이를 영속적으로 유지하기 위해 도커 볼륨을 사용할 수 있다. 볼륨은 독립적으로 운영되기 때문이다.

**도커 볼륨 타입**

![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7e375eab-c692-48ba-83d1-5759a27f7409%2FUntitled.png?table=block&id=ac1b3da7-fccc-4dd0-a682-79f834ab13cf&spaceId=b453bd85-cb15-44b5-bf2e-580aeda8074e&width=2000&userId=80352c12-65a4-4562-9a36-2179ed0dfffb&cache=v2)

- 호스트 파일 시스템의 특정 디렉터리와 컨테이너의 디렉터리를 연결하여 데이터를 저장하기 위해 다음 3가지 방법(volume, bind mount, tmpfs mount)이 제공된다.
- volume
    - 도커에서 권장하는 방법으로 `docker volume create 볼륨 이름`을 통해 볼륨을 생성한다.
    - 도커 볼륨은 도커 명렁어를 통해 관리할 수 있다.
    - 여러 컨테이너 간에 안전하게 공유할 수 있다.
    - 볼륨 드라이버를 통해 원격 호스트 및 클라우드 환경에 볼륨 내용을 저장하고 암호화할 수 있다.
    - 새 볼륨으로 지정될 영역에 데이터를 미리 채우고 컨테이너에 연결하면 컨테이너 내에서 바로 데이터 사용이 가능하다.
- bind mount
    - 도커 볼륨 기법에 비해 사용이 제한적이다.
    - `호스트 파일 시스템 절대 경로: 컨테이너 내부 경로`를 직접 마운트하여 사용한다.
    - 사용자가 파일 또는 디렉터리를 생성하면 해당 호스트 파일 시스템의 소유자 권한으로 연결이 되고, 존재하지 않는 경우 자동 생성된다.
    - 컨테이너 실행 시 지정하여 사용하고, 컨테이너 제거 시 바인드 마운트는 해제되지만 호스트 디렉터리는 유지된다.
- tmpfs mount
    - 컨테이너가 중지된 후에도 데이터를 유지할 수 있지만 tmpfs 마운트 방법은 임시적이며 호스트 메모리에서만 지속되므로 컨테이너가 중지되면 tmpfs 마운트가 제거되고 내부에 기록된 파일은 유지되지 않는다.
    - 호스트 또는 컨테이너 쓰기 가능 계층에서 지속하지 않지만 중요한 파일을 임시로 사용하는 방법에 유용하다.
    - 컨테이너 실행 시 지정하여 사용하고, 컨테이너 제거 시 자동 해제된다.

**도커 볼륨 활용**

```bash
# 볼륨 생성
$ docker volume create [볼륨 이름]

# 볼륨 목록 조회
$ docker volume ls

# 볼륨 검사 (볼륨이 올바르게 생성되고 마운트되었는지 확인)
$ docker volume inspect [볼륨 이름]
```

### 도커 컨테이너의 자원 사용에 대한 런타임 제약

- 서버 자원 모니터링 도구
    - top - 리눅스 전체의 자원 소비량 및 개별 액티브 프로세스의 자원 사용량
    - htop - top보다 향상된 자원 사용량 제공 (별도 설치 필요)
    - sar - 시스템 전반의 세부적인 모니터링 제공 (별도 설치 필요)
    - iostat, df - 디스크 성능 지표 모니터링
    - vmstat, free - 메모리 성능 측정
    - dstat - 서버 전반의 자원 사용량에 대한 모니터링 (별도 설치 필요)
    - iptraf-ng - 네트워크 트래픽 모니터링 (별도 설치 필요)
- 컨테이너는 프로세스이므로 위의 모니터링 도구에 의해 모니터링될 수 있다.
- 또한 도커에서 제공하는 여러 런타임 제약 옵션을 통해 컨테이너의 자원을 제한할 수 있다.
    - cpu 리소스 런타임 제약
    - 메모리 런타임 제약
    - 디스크 블록 I/O 런타임 제약

### 도커 네트워크

**도커 네트워크 개요**

- 도커 컨테이너 및 서비스는 도커 컨테이너를 통해 격리된 컨테이너 간의 네트워크 연결뿐만 아니라 도커 외의 다른 애플리케이션 워크로드와도 연결이 가능하다.
- 도커 설치 시 기본적으로 제공되는 docker0는 소프트웨어적으로 구현된 가상 이더넷 브릿지 네트워크이고, 이것을 통해 격리된 컨테이너들의 상호 간 통신을 제공한다.
    - 별도의 브릿지 네트워크를 생성하여 연결값으로 설정하지 않는 한 실행되는 모든 컨테이너는 docker0 브릿지에 연결되어 172.17.0.0/16의 CIDR 범위로 IP 주소가 할당된다.

![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc27f1780-66b6-4b62-9d1b-36dc004fd464%2FUntitled.png?table=block&id=b032605f-ea21-47db-bbb6-f0386de8dda1&spaceId=b453bd85-cb15-44b5-bf2e-580aeda8074e&width=2000&userId=80352c12-65a4-4562-9a36-2179ed0dfffb&cache=v2)

- 위 사진은 도커 브릿지 네트워크를 이용하여 연결된 구조이다. (아래는 네트워크 인터페이스 설명.)
    - docker0: 도커 설치 시 기본적으로 제공되는 브릿지 네트워크로 172.17.0.1 주소를 갖는다.
    - veth: OSI 7 계층 서비스 모델의 2계층 서비스로 컨테이너 내부에 제공되는 네트워크 인터페이스 eth0와 한 쌍으로 제공되어 docker0와 가상의 터널링 네트워크를 제공한다.
    - eth0: 도커 컨테이너에 생성되는 기본 네트워크 인터페이스명으로 docker0을 게이트웨이로 사용한다. 순차적으로 IP 주소를 할당받거나 사용자가 동일 대역의 IP 주소를 지정할 수 있다. (참고로 초록색 네모 박스의 eth0은 호스트의 네트워크 카드다. 또 다른 리눅스 네트워크 카드는 enp0s8이 있다.)
- 도커 네트워크 드라이버는 다음과 같다. (docker run 사용시 `—-network` 옵션을 이용하면 됨)
    - bridge: 기본 네트워크 드라이버로 컨테이너 실행 시 별도의 네트워크 지정 없이 독립적으로 실행되는 애플리케이션 컨테이너를 실행하는 경우 사용된다. (기본적으로 bridge 모드를 사용함.)
    - host: 컨테이너와 호스트 간의 네트워크 격리를 제거하고 호스트의 네트워킹을 직접 사용할 수 있다. 이 기능을 통해 컨테이너 애플리케이션에 별도의 포트 연결 없이 호스트의 포트를 이용하여 바로 서비스할 수 있다.
    - overlay: 다중 호스트 도커 서버를 이용한 클러스터 등을 이용할 경우 도커 데몬 간의 연결을 통해 컨테이너 서비스를 수행할 수 있다.
    - macvlan: 물리적 네트워크에 컨테이너 Mac 주소를 통한 직접 연결 구현 시 사용된다.
    - none: 컨테이너의 네트워크를 사용하지 않도록 설정한다. 이때 컨테이너는 외부와의 통신이 단절된다.

**도커 기본 브릿지 네트워크 활용**

![Untitled](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F177871fa-4345-480d-a463-fd8fb954e789%2FUntitled.png?table=block&id=318e5f26-d4df-4342-ada1-c18fbc696890&spaceId=b453bd85-cb15-44b5-bf2e-580aeda8074e&width=2000&userId=80352c12-65a4-4562-9a36-2179ed0dfffb&cache=v2)

- 오른쪽 각 container 들은 docker0에 의해 bridge 모드로 연결되어 있고, 이러한 형태의 Server 들은 overlay 모드로 연결된다.

**도커 사용자 정의 네트워크 활용**

- 사용자 정의 브릿지 네트워크와 docker run 수행 시 `--net-alias` 또는 `--link` 옵션으로 묶인 모든 컨테이너는 기본적으로 서비스를 검색할 수 있는 내장 DNS 서버가 제공된다. 이를 자동화 DNS 확인이라고 한다.
- 내장 DNS 서버는 특정 사용자 정의 네트워크에서 모든 컨테이너 별칭과 해당 IP 주소 간의 매핑을 유지한다.
- 이 DNS 서버는 포함된 컨테이너의 IP가 변경되거나 신규 컨테이너가 포함되면 자동 감지를 통해 해당 IP를 등록하고 반환한다.
- 도커는 외부 서비스와 컨테이너를 결합한 로드 밸런스 구현이 가능하다.
    - nginx를 주로 사용하며, 로드 밸런스 연결 알고리즘은 다음과 같다.
        - 라운드-로빈
        - 최소 연결
        - IP 해시
        - 일반 해시
        - 최소 시간
        - 무작위

### 도커 kill 명령과 초기화

- docker stop: 컨테이너 내에 메인 프로세스에 SIGTERM으로 종료를 전달하고, 기본값 10초 전까지 종료되지 않으면 SIGKILL을 보낸다. (정상 종료)
- docker kill: 바로 SIGKILL을 보내 비정상적 종료 처리가 되어 종료 코드 137을 발생시킨다. (비정상 종료)
- 호스트의 kill: 컨테이너에 접속한 호스트와 컨테이너의 세션을 끊는다. 이때 도커 컨테이너는 종료되지는 않는다.
