# 1️⃣ 컨테이너 서비스

## 1) 컨테이너 서비스란?

### **컨테이너의 의미**

- 사전적으로 해석해보면 어떤 사물을 격리할 수 있는 공간을 뜻한다.
- 컨테이너에 우리가 서비스하고자 하는 애플리케이션 코드와 프로세스를 격리한다는 의미로 생각하면 된다.

### **애플리케이션 개발환경이 도커 기반의 컨테이너 서비스 환경으로 전환된 이유?**

- 대부분의 개발자가 개발, 테스트, 배포, 운영의 컴퓨팅 환경(스토리지, 네트워크. 보안, 패치) 차이로 인한 오류를 해결에 많은 시간을 쏟는다.
- 이는 인프라 환경으로 인한 일관성 없는 환경 제공 때문이다.

### **컨테이너 서비스**

- 기존 환경과 다르게 애플리케이션 실행에 필요한 바이너리, 라이브러리 및 구성 파일 등을 패키지로 묶어 배포하는 방식으로 논리적 패키징 매커니즘을 제공한다.
- 애플리케이션이 가지고 있는 운영체제,  하드웨어(CPU, 메모리, 스토리지 등)에 대한 의존성 문제를 해결한 것이다.
- 따라서 어떤 환경에서든 컨테이너 기반의 애플리케이션을 개발하고 배포할 수 있다.
- 이렇게 호스트 운영체제를 공유하고 애플리케이션에 필요한 환경을 패키징하는 것을 **운영체제 레벨 가상화**라고 부른다.

### **가상화 방식**

- 하드웨어 레벨 가상화
    - 하이퍼바이저 등을 이용한 가상머신의 방식
- 운영체제 레벨 가상화
    - 컨테이너 기반의 애플리케이션 서비스 방식

## 2) 왜 도커 컨테이너 서비스일까?

- 도커 도입이 갖는 의미를 알기 위해서는 먼저 도커 기반 애플리케이션 개발의 과정을 이해해야 한다.
- 도커 기반 애플리케이션 개발의 라이프사이클
    1. 애플리케이션 코드 개발
    2. 베이스 이미지를 이용한 Dockerfile 작성
        - 개발에 필요한 인프라 구성 요소를 Dockerfile에 작성
    3. Dockerfile build를 통한 새로운 이미지 생성
    4. 생성된 이미지를 이용한 컨테이너 실행 or 도커컴포즈를 이용한 다중 컨테이너 실행
        - 도커 실행 옵션을 미리 작성한 docker-compose.yml을 통해 다중 컨테이너 간 실행 순서, 네트워크, 의존성 등을 통합 관리
    5. 마이크로서비스 테스트 or 컨테이너 애플리케이션 서비스 테스트
    6. 로컬 및 원격 저장소에 이미지 push
    7. 깃허브 등을 활용한 Dockerfile 관리
    8. 동일 환경에서의 지속적 애플리케이션 개발 수행
- 위 과정에서 눈여겨볼 것은 컨테이너 동작에 필요한 모든 내용을 사전에 코드로 작성하여 앤서블, 셰프, 베이그런트, 퍼핏과 같은 인프라 프로비저닝 도구로  자동화하게 되면 필요할 때마다 개발, 배포, 확장할 수 있다는 것이다. 이런 개념을 IaC(코드로서의 인프라스트럭처)라고 한다.

---

# 2️⃣ 도커 명령어 활용

## 1) 도커 이미지 명령어

### 도커 이미지 내려받기

`docker pull [IMAGE_NAME]`

- 명시적으로 최신 버전 지정
    - `docker pull [IMAGE_NAME]:latest`
- 이미지 식별 정보인 다이제스트 지정
    - `docker pull [IMAGE_NAME]:sha256:xxxxxxxxxxxxx`
    - 다이제스트값은 원격 도커 레지스트리(도커 허브)에서 관리하는 이미지의 고유 식별값을 뜻한다.

### 도커 이미지 세부 정보 조회

도커 오브젝트(이미지, 컨테이너 등)에 대한 세부 정보 조회를 위해 `docker image inspect`, `docker image history`, 물리적으로 호스트 운영체제에 저장된 영역을 이용한다.

`**docker inspect**`

```docker
docker image inspect [OPTION] IMAGE [IMAGE...]
```

- 세부 내용 중 몇 가지 주요 정보
    - image ID
    - 생성일
    - Docker 버전
    - CPU 아키텍쳐
    - 이미지 다이제스트 정보
    - 이미지 레이어 저장 정보
- 명령 옵션
    - -format
    - -f

`**docker image history**`

```docker
docker image history [OPTION] IMAGE

IMAGE          CREATED       CREATED BY                                      SIZE      COMMENT
b5543eff25e7   2 weeks ago   /bin/sh -c #(nop)  CMD ["httpd-foreground"]     0B
<missing>      2 weeks ago   /bin/sh -c #(nop)  EXPOSE 80                    0B
<missing>      2 weeks ago   /bin/sh -c #(nop) COPY file:c432ff61c4993ecd…   138B
<missing>      2 weeks ago   /bin/sh -c #(nop)  STOPSIGNAL SIGWINCH          0B
<missing>      2 weeks ago   /bin/sh -c set -eux;   savedAptMark="$(apt-m…   58.9MB
<missing>      2 weeks ago   /bin/sh -c #(nop)  ENV HTTPD_PATCHES=           0B
<missing>      2 weeks ago   /bin/sh -c #(nop)  ENV HTTPD_SHA256=eb397fee…   0B
<missing>      2 weeks ago   /bin/sh -c #(nop)  ENV HTTPD_VERSION=2.4.54     0B
<missing>      2 weeks ago   /bin/sh -c set -eux;  apt-get update;  apt-g…   3.87MB
<missing>      2 weeks ago   /bin/sh -c #(nop) WORKDIR /usr/local/apache2    0B
<missing>      2 weeks ago   /bin/sh -c mkdir -p "$HTTPD_PREFIX"  && chow…   0B
<missing>      2 weeks ago   /bin/sh -c #(nop)  ENV PATH=/usr/local/apach…   0B
<missing>      2 weeks ago   /bin/sh -c #(nop)  ENV HTTPD_PREFIX=/usr/loc…   0B
<missing>      2 weeks ago   /bin/sh -c #(nop)  CMD ["bash"]                 0B
<missing>      2 weeks ago   /bin/sh -c #(nop) ADD file:90344130400909b0a…   74.3MB
```

- 이 명령을 통해 현재 이미지 구성을 위해 사용된 레이블 정보와 각 레이어의 수행 명령, 크기 등을 조회할 수 있다.
- 출력 결과 중 CREATED BY 열을 보면 특정 이미지를 구성하기 위해 사용된 명령과 환경설정 등을 볼 수 있다.
- 이는 정보 중 용량을 가지고 있는 라인이 레이어다.

**다운로드한 이미지가 호스트 운영체제에 어떤 형태로 저장되어 있는지 살펴보자.**

이를 위해 이미지가 다운로드 되는 과정을 살펴보자.

```kotlin
docker pull httpd

// 출력
5b1423465504: Pull complete    ... 웹 애플리케이션 소스
ceb4a75630f5: Pull complete    ... 아파치 httpd 서버
f20566210577: Pull complete    ... 레이어3
ee03e037f8b6: Pull complete    ... 레이어2
8220bbf1aee7: Pull complete    ... 레이어1
```

간단히 표현하면 다음과 같은 구조다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0998e786-f306-4a75-bfdc-a7c46832fc99/Untitled.png)

1. 도커 이미지 구조의 기본 운영체제 레이어들을 쌓는다. (ubuntu)
2. 운영체제 베이스 이미지 위에 nginx를 설치한 레이어를 올린다. (nginx)
3. nginx에 필요한 리소스 정보 및 환경 정보가 포함된 레이어를 올린다. 이렇게 구성된 이미지는 **불변의 읽기 전용 레이어들의 집합 구조인 유니언 파일 시스템**이다.
4. 도커 이미지를 실행하면 여러 개의 컨테이너를 구동할 수 있다. 각각의 컨테이너에서 발생한 모든 변경 정보를 저장하기 위해 읽고-쓰기 레이어를 두고 저장하게 된다.

**왜 이런 구조를 사용할까?**

위 그림을 보면 이미지를 실행하여 여러 개의 컨테이너를 실행하는 것을 볼 수 있다. 처음 내려받은 이미지는 수백 메가 용량을 가지고 있지만 컨테이너를 구동할 때마다 이미지를 내려받지 않고 로컬에 저장된 이미지를 계속 사용한다. 또한, 이미지 레이어의 사단에 있는 웹 애플리케이션 소스 레이어의 환경 설정 및 리소스 설정이 변경되어 이미지로 변경되더라도 기존 레이어를 제외한 변경된 웹 소스 레이어만 내려받아 사용하기 때문에 효율적이다.

**그럼 호스트 운영체제에서는 어떻게 저장되는지 살펴보자.**

이거 명령어가 안먹히는데..?

### 도커 이미지 태그 설정

도커 태그는 원본 이미지에 참조 이미지 이름을 붙이는 명령어다. 사용법은 다음과 같다.

```docker
# 사용법
docker tag 원본 이미지[:태그] 참조 이미지[:태그]

# 이미지 ID에 세부 정보(OS, 버전 등)를 붙여 태그 지정.
docker image tag b2c2ab6dce14 debian:1.0

# 이미지 이름[:태그]에 세부 정보(OS, 버전 등)를 붙여 태그 지정.
docker image tag httpd:latest debian-httpd:2.0

# 도커 허브와 같은 레지스트리에 업로드하는 경우 저장소명과 함께 태그 지정.
docker image tag httpd:latest [본인 아이디]/httpd:3.0

# 알기 쉬운 이름으로 설정하고자 하는 경우 태그 지정.
docker image tag httpd webserver:4.0
```

### 도커 이미지를 파일로 관리

`docker image save` 명령은 도커 원본 이미지의 레이어 구조까지 포함한 복제를 수행하여 확장자 tar 파일로 이미지를 저장한다.

- 도커 허브로부터 이미지를 내려받아 내부망으로 이전하는 경우
- 신규 애플리케이션 서비스를 위해 Dockerfile로 새롭게 생성한 이미지를 저장 및 배포해야 하는 경우
- 컨테이너 완료(commit)하여 생성한 이미지를 저장 및 배포해야 하는 경우
- 개발 및 수정한 이미지 등

```docker
# 이미지 저장
docker image save mysql:5.7 > test-mysql57.tar

# 이미지 로드
docker image load test-mysql57.tar
```

### 도커 이미지 삭제

```docker
docker image rm [옵션] (이미지 이름[:태그] | 이미지 ID)
docker rmi [옵션] (이미지 이름[:태그] | 이미지 ID)
```

## 2) 도커 컨테이너 명령어

이미지는 읽기 전용의 불변 값으로 만들어진다. 이러한 이미지를 바탕으로 도커 엔진은 컨테이너를 생성할 수 있다.

컨테이너 구동, 접근, 로그, 운영 등의 명령은 dockerd 데몬이 제공하는 docker CLI API를 통해 제공된다.

### 컨테이너는 프로세스다

- 도커 컨테이너는 도커 이미지를 기반으로 만들어지는 스냅숏이다. 이 스냅숏은 읽기 전용의 도커 이미지 레이어를 복제한 것이고, 그 위에 읽고 쓰기가 가능한 컨테이너 레이어를 결합하면 컨테이너가 된다.

이러한 레이어들만 가지고 애플리케이션이 동작하는 것일까?

- 컴퓨터 애플리케이션의 동작은 프로세스를 통해 이루어진다. 컨테이너는 격리된 공간에서 프로세스가 동작하는 기술이다.
- `docker run ~` 을 사용하면 컨테이너가 동작하게 되고, 가상의 격리 환경에 독립된 프로세스가 동작한다. 마치 서버 호스트 운영체제가 독립적으로 동작하는 것과 유사하다.
- 리눅스 운영체제를 부팅하면 PID 1번은 init(systemd) 프로세스가 동작하며 이 프로세스는 나머지 모든 시스템 프로세스의 부모 프로세스가 된다.
- 도커 컨테이너(독립된 호스트 운영체제)도 마찬가지로 최상위 부모 프로세스가 필요하며, 시스템의 1번 프로세스(init)의 PID를 공유하고 그 하위 프로세스가 된다.
- 이렇게 격리된 프로세스를 루트로 변경하는 chroot 커널 기능을 통해 독립된 1번 PID를 갖게 되고, 컨테이너 동작 시 필요한 자원에 대한 할당은 cgroups 커널 기능을 통해 이루어진다.

### 컨테이너 실행

`**docker run`의 특징**

- 호스트 서버에 이미지가 다운로드되어 있지 않아도 로컬에 존재하지 않는 이미지를 도커 허브에서 자동으로 다운로드한다.
- 마지막에 해당 컨테이너에 실행할 명령을 입력하면 컨테이너 동작과 함께 처리된다.

**`docker run` 자주 사용하는 옵션**

| 옵션 | 설명 |
| --- | --- |
| -i, —interactive | 대화식 모드 열기 |
| -t | TTY(단말 디바이스) 할당 |
| -d, —detach=true | 백그라운드에서 컨테이너 실행 후 컨테이너 ID 등록 |
| —name | 실행되는 컨테이너에 이름 부여 |
| —rm | 컨테이너 종료 시 자동으로 컨테이너 제거 |
| —restart | 컨테이너 종료 시 적용할 재시작 정책 지정 |
| —env | 컨테이너의 환경 변수 지정 |
| -v,
—volume=호스트경로:컨테이너경로 | 호스트 경로와 컨테이너 경로의 공유 볼륨 설정 |
| -h | 컨테이너 호스트명 지정 |
| -p [Host 포트]:[Container 포트],
—publish | 호스트 포트와 컨테이너 포트 연결 |

### 실습 1 - 컨테이너 모니터링 도구 cAdvisor 컨테이너 실행

- 서비스 운영을 하면서 필요한 시스템 Metric(CPU/메모리 사용률, 네트워크 트래픽 등)을 모니터링하면서 특이사항이 있을 때 대응하기 위해 모니터링 수행
- 그러나 컨테이너라는 환경하에서는 기존 모니터링 도구로는 container 모니터링 진행이 어려움
- 이러한 문제점을 해결하고 컨테이너를 모니터링하기 위한 도구로 구글에서 제공하는 cAdvisor를 많이 사용함.

### 실습 2 - 웹 서비스 실행을 위한 Nginx 컨테이너 실행

```docker
# Nginx 컨테이너를 실행
# -name : 컨테이너의 이름을 지정
# -d 옵션 : 컨테이너를 백그라운드에서 실행하고 컨테이너 ID를 출력
# -p 옵션 : 컨테이너의 80번 포트를 Host 포트 8001로 오픈
docker run --name webserver1 -d -p 8001:80 nginx:1.18

# 컨테이너의 리소스 사용량 실시간 확인
docker stats webserver1

# 컨테이너의 실행 중인 프로세스 표시
docker top webserver1

# nginx 컨테이너의 접근 로그 확인
# -f : 실시간
# -t : 마지막로그까지
docker logs -f webserver1

# 컨테이너 중지
# docker stop 명령은 SIGKILL 시그널을 전송하여 컨테이너 프로세스를 정지
docker stop webserver1

# 컨테이너 재실행
docker restart webserver1

# 지정된 컨테이너 일시 중단 (관련된 모든 프로세스를 일시중단)
# 리눅스에서는 freezer cgroup을 사용
docker pause webserver1

# 지정된 컨테이너의 모든 프로세스에서 일시 중단 해제
docker unpause webserver1
```

컨테이너  내부에 소스 코드, 구성 정보(*.conf) 등을 변경하는 경우 `docker cp`가 유용하다. nginx의 구성 파일인 nginx.conf를 수정해야 한다면 굳이 컨테이너에 편집기를 설치하는 수고를 들이거나 경량의 컨테이너를 무겁게 할 필요가 없다.

```docker
# nginx 컨테이너를 만든다
docker run -d -p 8010:80 --name=webserver10 nginx:latest

# nginx 컨테이너의 nginx.conf를 호스트로 복사해 온다
docker cp webserver10:/etc/nginx/nginx.conf ./nginx.conf

# nginx 구성 정보를 변경하고 원래 위치에 복사해 준다
docker cp nginx.conf webserver10:/etc/nginx.nginx.conf

# nginx 컨테이너를 재시작해 준다.
docker restart webserver10
```

## 3) 도커 볼륨 활용

- 데이터베이스, 웹 프로그램 등 업무에서 사용하는 애플리케이션에서 발생하는 데이터에 접근하고 이것을 공유하기 위해서 도커 볼륨 기능을 사용할 수 있다.
- 도커 볼륨은 컨테이너에서 생성, 재사용할 수 있고 호스트 운영체제에서 직접 접근이 가능하다.
- 또한 보존되어야 하는 데이트를 유지하기 위한 메커니즘을 지공한다. (일반적으로 컨테이너 내부의 데이터는 컨테이너 종료 시 삭제된다.)
- 도커 볼륨을 사용하면 컨테이너가 삭제되어도 볼륨은 독립적으로 운영되기 때문에 삭제되지 않는 특징이 있다.

### 도커 볼륨 타입

호스트 파일 시스템의 특정 디렉터리와 컨테이너의 디렉터리를 연결하여 데이터를 저장하기 위해 다음과 같은 방법이 제공된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f6d23e68-f4fc-440b-8a83-99d9871edf36/Untitled.png)

**Volume**

- 도커에서 권장하는 방법으로는 `docker volume create 볼륨 이름`을 통해 볼륨을 생성한다.
- 도커 볼륨은 도커 명령어를 통해 관리할 수 있다.
- 여러 컨테이너 간에 안전하게 공유할 수 있다.
- 새 볼륨으로 지정될 영역에 데이터를 미리 채우고 컨테이너에 연결하면 컨테이너 내에서 바로 데이터 사용이 가능하다.

```docker
# 볼륨 생성
docker volume create my-appvol-1

# 생성된 볼륨 조회
docker volume ls

# 볼륨 검사, 볼륨이 올바르게 생성되고 마운트되었는지 확인하는 데 사용
docker volume inspect my-appvol-1

# --mount 옵션을 이용한 볼륨 지정
docker run -d --name vol-test1 \
--mount source=my-appvol-1,target=/app \
ubuntu:20:04

# -v 옵션을 이용한 볼륨 지정
# 사전에 docker volume create를 하지 않아도 호스트 볼륨 이름을 쓰면 자동 생성
docker run -d --name vol-test2 \
-v my-appvol-1"/var/log \
ubuntu:20.04

# 볼륨 제거, 현재 연결된 컨테이너가 있으면 아래와 같은 에러가 발생
docker volume rm my-appvol-1

# 연결된 컨테이너 제거 후 볼륨 삭제
docker stop vol-test1
docker rm vol-test1
docker volume rm my-appvol-1
```

### 실습 1 - 웹 서비스의 로그 정보 보호 및 분석을 위한 바인드 마운트 설정

- nginx의 접근 기록 정보인 access.log를 통해 장애 시 장애 상황 정보를 파악하거나 실시간 접근 로그를 분석할 수 있다.

```docker
docker run -d -p 8011:80 \
-v nginx-log:/var/log/nginx \
nginx:1.18

# tail 명령을 이용해 실시간으로 접근되는 로그 정보를 수집
tail -f nginx-log/access.log
```

### 실습 2 - 컨테이너 간 데이터 공유를 위한 데이터 컨테이너 만들기

- 컨테이너 볼륨으로 지정된 디렉터리로부터 볼륨 마운트를 할 수 있다.
- 실습에서는 여러 컨테이너가 데이터를 공유해서 사용할 수 있도록 데이터 전용 컨테이너를 생성하고, 이 컨테이너에서 의도한 공유 볼륨을 여러 컨테이너에 연결할 것이다.
- 이를 통해 데이터 컨테이너를 만들 수 있고, 컨테이너 내의 데이터베이스 백업, 복구 및 마이그레이션 등의 작업에 활용할 수 있다.

### 실습 3 - 볼륨 용량 제한

- 볼륨으로 연결된 컨테이너 내부에서 `df -h` 명령을 통해 마운트된 디렉터리(/webapp)의 공간을 조회해 보면 호스트 운영체제의 최상위 영역 /(루트 디렉터리)와 /webapp 디렉터리의 용량이 같은 것을 알 수 있다.
- 리눅스에서 사용하는 `dd` 명령어를 통해 임시 영역 512MB를 생성하고 이 임시 영역을 파일 시스템으로 만들어 볼륨 디렉터리로 사용하면, 컨테이너 내부에서 사용할 수 있는 볼륨 공간이 생긴다

## 4) 도커 컨테이너의 자원 사용에 대한 런타임 제약

### 서버 자원 모니터링

자원(CPU, 메모리, 디스크 I/O, 네트워크 트래픽)을 모니터링하기 위해 다음과 같은 도구를 종종 사용한다.

| 도구 | 설명 |
| --- | --- |
| top | 리눅스 전체의 자원 소비 량 및 개별 액티브 프로세스 자원 사용량 |
| htop | top보다 향상된 자원 사용량 제공(별도 설치 요구) |
| sar | 다양한 옵션을 통해 시스템 전반의 사용량에 대한 세부적인 모니터링 제공, 주로 셀 스크립트에 포함하여 활용(별도 설치 요구)
sar 2 10(2초 간격으로 10초 동안 수집) |
| iostat, df | 디스크 성능 지표인 IOPS와 MBPS 측정 가능(sar과 함께 설치) |
| vmstat, free | 메모리 성능 측정이 가능 |
| dstat | 서버 전반의 자원 사용량에 대한 모니터링 제공, 개별 옵션으로 제어 가능(별도 설치 요구) |
| iptraf-ng | 서버로 유입되는 네트워크 인터페이스별 패킷양, 프로토콜 등을 통해 네트워크 트래픽 모니터링(별도 설치 요구) |

컨테이너를 생성하는 `docker run`, `docker create` 명령과 함께 자원 할당 제어를 사용하지 않는다면 생성되는 컨테이너는 호스트 운영체제의 모든 자원을 자유롭게 사용하고, 과도한 자원 사용도 가능하다.

컨테이너 생성 시 도커에서 제공하는 여러 런타임 제약 옵션을 통해 컨테이너의 자원을 어떻게 효율적으로 운영할지 정할 수 있다. 컨테이너 생성 후에도 `docker update` 명령을 통해 변경이 가능하다.

```docker
# 메모리 1GB 설정
docker run -d --memeory=1g --name=nginx_mem_1g nginx

# inspect로 조회
docker inspect nginx_mem_1g | grep \"Memory\"
# 출력
Memory": 1073741824
```

---

# 3️⃣ 도커 네트워크

## 1) **도커 네트워크 개요**

- 도커 컨테이너 및 서비스는 도커 컨테이너를 통해 격리된 컨테이너 간의 네트워크 연결뿐만 아니라 도커 외의 다른 애플리케이션 워크로드와도 연결이 가능하다.
- 도커 설치 시 기본적으로 제공되는 docker0는 소프트웨어적으로 구현된 가상 이더넷 브릿지 네트워크이고, 이것을 통해 격리된 컨테이너들의 상호 간 통신을 제공한다.
    - 별도의 브릿지 네트워크를 생성하여 연결값으로 설정하지 않는 한 실행되는 모든 컨테이너는 docker0 브릿지에 연결되어 172.17.0.0/16의 CIDR 범위로 IP 주소가 할당된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c27f1780-66b6-4b62-9d1b-36dc004fd464/Untitled.png)

- 위 사진은 도커 브릿지 네트워크를 이용하여 연결된 구조이다. (아래는 네트워크 인터페이스 설명.)
    - **docker0**
        - 도커 설치 시 기본적으로 제공되는 브릿지 네트워크로 172.17.0.1 주소를 갖는다.
    - **veth**
        - OSI 7 계층 서비스 모델의 2계층 서비스로 컨테이너 내부에 제공되는 네트워크 인터페이스 eth0와 한 쌍으로 제공되어 **docker0와 가상의 터널링 네트워크를 제공**한다.
    - **eth0**
        - 도커 컨테이너에 생성되는 기본 네트워크 인터페이스명으로 docker0을 게이트웨이로 사용한다. 순차적으로 IP 주소를 할당받거나 사용자가 동일 대역의 IP 주소를 지정할 수 있다. **(참고로 초록색 네모 박스의 eth0은 호스트의 네트워크 카드다. 또 다른 리눅스 네트워크 카드는 enp0s8이 있다.)**

- 도커 네트워크 드라이버는 다음과 같다. (docker run 사용시 `—-network` 옵션을 이용하면 됨)
    - **bridge**
        - 기본 네트워크 드라이버로 컨테이너 실행 시 별도의 네트워크 지정 없이 독립적으로 실행되는 애플리케이션 컨테이너를 실행하는 경우 사용된다. (기본적으로 bridge 모드를 사용함.)
    - **host**
        - 컨테이너와 호스트 간의 네트워크 격리를 제거하고 호스트의 네트워킹을 직접 사용할 수 있다. 이 기능을 통해 컨테이너 애플리케이션에 별도의 포트 연결 없이 호스트의 포트를 이용하여 바로 서비스할 수 있다.
    - **overlay**
        - 다중 호스트 도커 서버를 이용한 클러스터(도커 스웜) 등을 이용할 경우 도커 데몬 간의 연결을 통해 컨테이너 서비스를 수행할 수 있다.
    - **macvlan**
        - 물리적 네트워크에 컨테이너 Mac 주소를 통한 직접 연결 구현 시 사용된다.
    - **none**
        - 컨테이너의 네트워크를 사용하지 않도록 설정한다. 이때 컨테이너는 외부와의 통신이 단절된다.

## 2) **도커 기본 브릿지 네트워크 활용**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/177871fa-4345-480d-a463-fd8fb954e789/Untitled.png)

- 오른쪽 각 container들은 docker0에 의해 bridge 모드로 연결되어 있고, 이러한 형태의 Server들은 overlay 모드로 연결된다.

## 3) **도커 사용자 정의 네트워크 활용**

- 사용자 정의 브릿지 네트워크와 docker run 수행 시 `--net-alias` 또는 `--link` 옵션으로 묶인 모든 컨테이너는 기본적으로 서비스를 검색할 수 있는 내장 DNS 서버가 제공된다. 이를 자동화 DNS 확인이라고 한다.
- 내장 DNS 서버는 특정 사용자 정의 네트워크에서 모든 컨테이너 별칭과 해당 IP 주소 간의 매핑을 유지한다.
- 이 DNS 서버는 포함된 컨테이너의 IP가 변경되거나 신규 컨테이너가 포함되면 자동 감지를 통해 해당 IP를 등록하고 반환한다.
- 도커는 외부 서비스와 컨테이너를 결합한 로드 밸런스 구현이 가능하다.
    - nginx를 주로 사용하며, 로드 밸런스 연결 알고리즘은 다음과 같다.
        - 라운드-로빈
        - 최소 연결
        - IP 해시
        - 일반 해시
        - 최소 시간
        - 무작위

---

# 4️⃣ 도커 kill 명령과 초기화

- docker stop: 컨테이너 내에 메인 프로세스에 SIGTERM으로 종료를 전달하고, 기본값 10초 전까지 종료되지 않으면 SIGKILL을 보낸다. (정상 종료)
- docker kill: 바로 SIGKILL을 보내 비정상적 종료 처리가 되어 종료 코드 137을 발생시킨다. (비정상 종료)
- 호스트의 kill: 컨테이너에 접속한 호스트와 컨테이너의 세션을 끊는다. 이때 도커 컨테이너는 종료되지는 않는다.
